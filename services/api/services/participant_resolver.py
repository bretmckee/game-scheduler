# Copyright 2025-2026 Bret McKee
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


"""
Participant resolver service for validating and resolving @mentions.

Handles resolution of Discord user mentions and placeholder strings for
pre-populating game participant lists.
"""

import logging
import re
from typing import Any

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from starlette import status

from shared.discord import client as discord_client_module
from shared.models import user as user_model

logger = logging.getLogger(__name__)


class ValidationError(Exception):
    """Validation error for participant resolution."""

    def __init__(self, invalid_mentions: list[dict], valid_participants: list[str]) -> None:
        """
        Initialize validation error.

        Args:
            invalid_mentions: List of invalid mention errors
            valid_participants: List of successfully resolved participants
        """
        self.invalid_mentions = invalid_mentions
        self.valid_participants = valid_participants
        super().__init__(f"Failed to resolve {len(invalid_mentions)} mentions")


class ParticipantResolver:
    """Resolves initial participant list from @mentions and placeholders."""

    def __init__(self, discord_client: discord_client_module.DiscordAPIClient) -> None:
        """
        Initialize participant resolver.

        Args:
            discord_client: Discord API client for member search
        """
        self.discord_client = discord_client
        # Pattern to match Discord mention format: <@123456789012345678>
        self._discord_mention_pattern = re.compile(r"^<@(\d{17,20})>$")

    async def _resolve_discord_mention_format(
        self,
        guild_discord_id: str,
        input_text: str,
        discord_id: str,
    ) -> tuple[dict | None, dict | None]:
        """
        Resolve Discord internal mention format <@discord_id>.

        Args:
            guild_discord_id: Discord guild snowflake ID
            input_text: Original input text
            discord_id: Extracted Discord user ID

        Returns:
            Tuple of (valid_participant, validation_error)
            Returns (participant_dict, None) on success, (None, error_dict) on failure
        """
        try:
            member = await self.discord_client.get_guild_member(guild_discord_id, discord_id)
            return (
                {
                    "type": "discord",
                    "discord_id": discord_id,
                    "username": member["user"]["username"],
                    "display_name": (
                        member.get("nick")
                        or member["user"].get("global_name")
                        or member["user"]["username"]
                    ),
                    "original_input": input_text,
                },
                None,
            )
        except discord_client_module.DiscordAPIError as e:
            if e.status == status.HTTP_404_NOT_FOUND:
                return (
                    None,
                    {
                        "input": input_text,
                        "reason": "User not found in server",
                        "suggestions": [],
                    },
                )
            logger.error(
                "Discord API error fetching member %s from guild %s: %s - %s",
                discord_id,
                guild_discord_id,
                e.status,
                e.message,
            )
            return (
                None,
                {
                    "input": input_text,
                    "reason": f"Discord API error: {e.message}",
                    "suggestions": [],
                },
            )
        except Exception as e:
            logger.exception(
                "Unexpected error fetching guild member %s: %s",
                discord_id,
                e,
            )
            return (
                None,
                {
                    "input": input_text,
                    "reason": "Internal error fetching user",
                    "suggestions": [],
                },
            )

    async def _resolve_user_friendly_mention(
        self,
        guild_discord_id: str,
        input_text: str,
        mention_text: str,
        access_token: str,
    ) -> tuple[dict | None, dict | None]:
        """
        Resolve user-friendly @username mention via search.

        Args:
            guild_discord_id: Discord guild snowflake ID
            input_text: Original input text (@username)
            mention_text: Username to search (without @)
            access_token: User's access token for Discord API calls

        Returns:
            Tuple of (valid_participant, validation_error)
            Returns (participant_dict, None) on single match
            Returns (None, error_dict) on no match, multiple matches, or error
        """
        try:
            members = await self._search_guild_members(guild_discord_id, mention_text, access_token)

            if len(members) == 0:
                return (
                    None,
                    {
                        "input": input_text,
                        "reason": "User not found in server",
                        "suggestions": [],
                    },
                )
            if len(members) == 1:
                return (
                    {
                        "type": "discord",
                        "discord_id": members[0]["user"]["id"],
                        "original_input": input_text,
                    },
                    None,
                )

            # Multiple matches - disambiguation needed
            suggestions: list[dict[str, str]] = [
                {
                    "discordId": m["user"]["id"],
                    "username": m["user"]["username"],
                    "displayName": (
                        m.get("nick") or m["user"].get("global_name") or m["user"]["username"]
                    ),
                }
                for m in members[:5]
            ]
            return (
                None,
                {
                    "input": input_text,
                    "reason": "Multiple matches found",
                    "suggestions": suggestions,
                },
            )

        except discord_client_module.DiscordAPIError as e:
            logger.error(
                "Discord API error searching guild %s for query '%s': %s - %s",
                guild_discord_id,
                mention_text,
                e.status,
                e.message,
            )
            return (
                None,
                {
                    "input": input_text,
                    "reason": f"Discord API error: {e.message}",
                    "suggestions": [],
                },
            )
        except Exception as e:
            logger.exception(
                "Unexpected error searching guild members for '%s': %s",
                mention_text,
                e,
            )
            return (
                None,
                {
                    "input": input_text,
                    "reason": "Internal error searching for user",
                    "suggestions": [],
                },
            )

    def _create_placeholder_participant(self, input_text: str) -> dict:
        """
        Create placeholder participant entry.

        Args:
            input_text: Placeholder display name

        Returns:
            Placeholder participant dictionary
        """
        return {
            "type": "placeholder",
            "display_name": input_text,
            "original_input": input_text,
        }

    async def _process_single_participant_input(
        self,
        guild_discord_id: str,
        input_text: str,
        access_token: str,
    ) -> tuple[dict | None, dict | None]:
        """
        Process a single participant input and resolve to participant or error.

        Args:
            guild_discord_id: Discord guild snowflake ID
            input_text: Single participant input (@mention, <@id>, or placeholder)
            access_token: User's access token for Discord API calls

        Returns:
            Tuple of (participant_dict, error_dict) - one will be None
        """
        input_text = input_text.strip()

        if not input_text:
            return None, None

        mention_match = self._discord_mention_pattern.match(input_text)
        if mention_match:
            discord_id = mention_match.group(1)
            return await self._resolve_discord_mention_format(
                guild_discord_id, input_text, discord_id
            )

        if input_text.startswith("@"):
            mention_text = input_text[1:].lower()
            return await self._resolve_user_friendly_mention(
                guild_discord_id, input_text, mention_text, access_token
            )

        return self._create_placeholder_participant(input_text), None

    async def resolve_initial_participants(
        self,
        guild_discord_id: str,
        participant_inputs: list[str],
        access_token: str,
    ) -> tuple[list[dict], list[dict]]:
        """
        Resolve initial participant list from @mentions and placeholders.

        Accepts both user-friendly format (@username) and Discord internal format (<@discord_id>).

        Args:
            guild_discord_id: Discord guild snowflake ID
            participant_inputs: List of @mentions, <@discord_id>, or placeholder strings
            access_token: User's access token for Discord API calls

        Returns:
            Tuple of (valid_participants, validation_errors)
            valid_participants: List of dicts with type, discord_id/display_name
            validation_errors: List of dicts with input, reason, suggestions
        """
        valid_participants = []
        validation_errors: list[dict[str, Any]] = []

        for input_text in participant_inputs:
            participant, error = await self._process_single_participant_input(
                guild_discord_id, input_text, access_token
            )

            if participant:
                valid_participants.append(participant)
            if error:
                validation_errors.append(error)

        return valid_participants, validation_errors

    async def _search_guild_members(
        self,
        guild_discord_id: str,
        query: str,
        _access_token: str,
    ) -> list[dict]:
        """
        Search guild members by query string.

        Args:
            guild_discord_id: Discord guild snowflake ID
            query: Search query (username, global_name, or nickname)
            access_token: User's access token for Discord API calls

        Returns:
            List of member objects matching the query

        Raises:
            DiscordAPIError: If API call fails
        """
        url = f"https://discord.com/api/v10/guilds/{guild_discord_id}/members/search"
        params: dict[str, str | int] = {"query": query, "limit": 10}

        session = await self.discord_client._get_session()

        try:
            async with session.get(
                url,
                params=params,
                headers={"Authorization": f"Bot {self.discord_client.bot_token}"},
            ) as response:
                if response.status != status.HTTP_200_OK:
                    try:
                        response_data = await response.json()
                        error_msg = response_data.get("message", "Unknown error")
                    except Exception:
                        error_msg = f"HTTP {response.status}"

                    logger.error(
                        "Discord API error searching guild %s: %s - %s",
                        guild_discord_id,
                        response.status,
                        error_msg,
                    )
                    raise discord_client_module.DiscordAPIError(response.status, error_msg)

                return await response.json()

        except discord_client_module.DiscordAPIError:
            raise
        except Exception as e:
            logger.exception(
                "Network error searching guild members in %s: %s",
                guild_discord_id,
                e,
            )
            raise discord_client_module.DiscordAPIError(
                status.HTTP_500_INTERNAL_SERVER_ERROR, f"Network error: {e!s}"
            ) from e

    async def ensure_user_exists(
        self,
        db: AsyncSession,
        discord_id: str,
    ) -> user_model.User:
        """
        Ensure user exists in database, create if not.

        Does not commit. Caller must commit transaction. Uses flush() to
        generate user ID if creating new user.

        Args:
            db: Database session
            discord_id: Discord user snowflake ID

        Returns:
            User model instance
        """
        result = await db.execute(
            select(user_model.User).where(user_model.User.discord_id == discord_id)
        )
        user = result.scalar_one_or_none()

        if user is None:
            user = user_model.User(discord_id=discord_id)
            db.add(user)
            await db.flush()

        return user
